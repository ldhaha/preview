<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body></body>
	<script src="https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js"></script>

	<script>
		const { reactive, effect, shallowReactive, shallowReadonly } = VueReactivity;
		const MyComponent = {
			name: 'MyComponent',
			props: {
				title: String,
			},
			data() {
				return {
					count: 1,
				};
			},
			render() {
				return {
					type: 'div',
					children: `我是文本 ${this.count}`,
				};
			},
		};

		const CompVNode = {
			type: MyComponent,
			props: {
				class: 'my-class',
			},
		};

		function hasPropsChanged(oldProps, newProps) {
			const newPropsKeys = Object.keys(newProps);
			if (newPropsKeys.length !== Object.keys(oldProps).length) {
				return true;
			}
			for (let key in newProps) {
				if (newProps[key] !== oldProps[key]) {
					return true;
				}
			}
			return false;
		}

		function patchComponent(n1, n2, anchor) {
			const instance = (n2.component = n1.component);
			const { props } = instance;
			if (hasPropsChanged(n1.props, n2.props)) {
				const [nextProps] = resolveProps(n2.type.props, n2.props);
				for (const k in nextProps) {
					props[k] = nextProps[k];
				}

				for (const k in props) {
					if (!(k in nextProps)) {
						props[k] = undefined;
					}
				}
			}
		}

		function patch(n1, n2, container, anchor) {
			/* 省略之前的判断 */
			if (typeof type === 'object') {
				if (!n1) {
					mountComponent(n2, container, anchor);
				} else {
					patchComponent(n1, n2, anchor);
				}
			}
		}

		function resolveProps(options, propsData) {
			const props = {};
			const attrs = {};
			for (const key in propsData) {
				if (key in options || key.startsWith('on')) {
					props[key] = propsData[key];
				} else {
					attrs[key] = propsData[key];
				}
			}
			return [props, attrs];
		}

		function onMounted(callback) {
			currentInstance?.mounted?.push(callback);
		}

		function mountComponent(vnode, container, anchor) {
			const componentOptions = vnode.type;
			const {
				render,
				data,
				beforeCreate,
				created,
				beforeMount,
				mounted,
				beforeUpdate,
				updated,
				props: propsOptions,
				setup,
			} = componentOptions;

			beforeCreate?.();

			const state = reactive(data());

			const [props, attrs] = resolveProps(propsOptions, vnode.props);

			const instance = {
				state,
				isMounted: false,
				subTree: null,
				props: shallowReactive(props),
				mounted: [],
			};

			function emit(event, ...args) {
				const eventName = event.slice(0, 2) === 'on' ? event.slice(2).toLowerCase() : event;
				const handler = instance.props[`on${eventName}`];
				handler?.(...args);
			}

			let currentInstance = null;
			function setCurrentInstance(instance) {
				currentInstance = instance;
			}
			const slots = vnode.children || {};

			const setupContext = { attrs, emit, slots };
			setCurrentInstance(instance);

			const setupResult = setup?.(shallowReadonly(instance.props), setupContext);
			setCurrentInstance(null);

			let setupState = null;

			if (typeof setupResult === 'function') {
				if (render) {
					console.log('setup返回了渲染函数，render将忽略');
					render = setupResult;
				} else {
					setupState = setupResult;
				}
			}

			const renderContext = new Proxy(instance, {
				get(t, k, r) {
					const { state, props, slots } = t;
					if (k === '$slots') {
						return slots;
					} else if (state && k in state) {
						return state[k];
					} else if (k in props) {
						return props[k];
					} else if (setupState && k in setupState) {
						// 渲染上下文需要增加对 setupState 的支持
						return setupState[k];
					} else {
						console.error('不存在');
					}
				},
				set(t, k, v, r) {
					const { state, props } = t;
					if (state && k in state) {
						state[k] = v;
					} else if (k in props) {
						console.warn(`Attempting to mutate prop "${k}". Props 
are readonly.`);
					} else if (setupState && k in setupState) {
						// 渲染上下文需要增加对 setupState 的支持
						setupState[k] = v;
					} else {
						console.error('不存在');
					}
				},
			});

			vnode.component = instance;

			created?.call(renderContext);

			// 改变this指向，指向响应式的数据,state改变重新渲染
			effect(() => {
				const subTree = render.call(renderContext, renderContext);
				if (!instance.isMounted) {
					beforeMount?.call(renderContext);
					patch(null, subTree, container, anchor);
					instance.isMounted = true;
					instance.mounted.forEach(fn => fn());
					mounted?.call(renderContext);
				} else {
					beforeUpdate?.call(renderContext);
					patch(instance.subTree, subTree, container, anchor);
					updated?.call(renderContext);
				}
				instance.subTree = subTree;
			});
		}
	</script>
</html>
